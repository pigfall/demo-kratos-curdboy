// do not edit, auto generated by curdboy

package curd

import(
	"context"
	"github.com/pigfall/demo-kratos-curdboy/ent"
	"github.com/pigfall/demo-kratos-curdboy/ent/predicate"
	"github.com/pigfall/curdboy/pkgs/filter"
	"github.com/pigfall/demo-kratos-curdboy/ent/user"
	"fmt"
	"strings"
)

/*{ the number is meanning less. I just use it as mark to jump between the code
1တ   | struct User: as the model in db
2တ   | func (*User)fromEntUser: convert model in ent to curdboy node model
3တ   | func UserCreate: func to create node
4တ   | func UserQuery: func to query nodes by pages
5တ   | func UserCount: func to count nodes
51တ  | func UserUpdate: func to update nodes
52တ  | func UserDelete: func to update nodes
6တ   | func ParseFilterToUserPredicate: func to parse fitler string to node predicate
တ7   | functions to convert field value from interface to real type
တ8   | parse fields expr to field selector object which is used to select the field we want to query
}*/

// { 
// 1တ
type User struct {
  *ent.User
  Edges interface{} `json:"-"` // no need the edges from base class
  
}

// 2တ
func (this *User) fromEntUser(base *ent.User,selector *UserFieldsSelector)error{
  this.User = base
  return nil
}

// }

// { CURD
// 3တ 
func UserCreate (ctx context.Context,fieldsData map[string]interface{},entCli *ent.Client)(id int,outErr error){
  mutation := entCli.User.Create()
  for k,v := range fieldsData {
    _ = v
    switch k {
    case "name":
      value,err := UserNameValueFromInterface(v)
      if err != nil {
        outErr = fmt.Errorf("field name type not match for node User: %w",err)
        return 
      }
      mutation.SetName(value)
    case "age":
      value,err := UserAgeValueFromInterface(v)
      if err != nil {
        outErr = fmt.Errorf("field age type not match for node User: %w",err)
        return 
      }
      mutation.SetAge(value)
      case "id":
      outErr = fmt.Errorf("field id is auto generated, do not set value to the field")
      return
    default:
      outErr = fmt.Errorf("undefined field %s for node User",k)
      return 
    }
  }
  record,err := mutation.Save(ctx)
  if err != nil {
    outErr = err
    return
  }
  return record.ID,nil
}

// 4တ 
func UserQuery (ctx context.Context,req *QueryRequest,entCli *ent.Client)([]*User,error ){
	var pred predicate.User
	if len(req.Filter) > 0{
    var err error
    pred,err = ParseFilterToUserPredicate(req.Filter)
		if err != nil{
			return nil,err
		}
	}
	query := entCli.User.Query().Limit(req.PageSize).Offset(req.PageIndex * req.PageSize)
	if pred != nil{
		query = query.Where(pred)
	}

  // { fields selector
  fldSelector,err := ParseUserFieldsSelector(req.Fields)
  if err != nil{
    return nil,err
  }
  // }

	records,err :=  query.All(ctx)
  if err != nil{
    return nil,err
  }
  // { convert to our node struct
  nodes := make([]*User,0,len(records))
  for _,r := range records{
    node := &User{}
    err := node.fromEntUser(r,fldSelector)
    if err != nil{
      return nil,err
    }
    nodes = append(nodes,node)
  }
  // }

  return nodes,nil
}

// 5တ 
func UserCount (ctx context.Context,entCli *ent.Client,filter string)(int,error){
  query := entCli.User.Query()
  if len(filter)>0{
    pred,err := ParseFilterToUserPredicate(filter)
    if err != nil{
      return 0, err
    }
    query.Where(pred)
  }
  return query.Count(ctx)
}

// 51တ 
func UserUpdate (ctx context.Context,entCli *ent.Client,req *UpdateRequest)(error){
  mutation := entCli.User.Update()
  if len(req.Filter) > 0{
    pred,err := ParseFilterToUserPredicate(req.Filter)
    if err != nil{
      return err
    }
    mutation.Where(pred)
  }
  for field,v := range req.Data{
    _ = v
    switch field {
    case "name":
    value,err := UserNameValueFromInterface(v)
    if err != nil {
      err = fmt.Errorf("field name type not match for node User: %w",err)
      return err
    }
    mutation.SetName(value)
    case "age":
    value,err := UserAgeValueFromInterface(v)
    if err != nil {
      err = fmt.Errorf("field age type not match for node User: %w",err)
      return err
    }
    mutation.SetAge(value)
    case "id":
    err := fmt.Errorf("field id is auto generated, do not set value to the field")
    return err
    default:
      return fmt.Errorf("undefined field < %s > for node < User >",field)
    }
  }
  _,err := mutation.Save(ctx)
  return err
}

// 52တ
func UserDelete (ctx context.Context,entCli *ent.Client,filter string)(error){
  del := entCli.User.Delete()
  if len(filter) > 0{
    pred,err := ParseFilterToUserPredicate(filter)
    if err != nil{
      return err
    }
    del.Where(pred)
  }
  _,err := del.Exec(ctx)
  return err
}
// }



// { Prase filter to node predicate
// 6တ 
func ParseFilterToUserPredicate(filterStr string)(predicate.User,error){
  if len(filterStr) == 0{
    return nil,fmt.Errorf("length of filter can not be 0")
  }
  filterExpr,err := filter.ParseFilter(filterStr)
  if err != nil{
    return nil,err
  }
  pred,err := ToUserPredicate(filterExpr)
  if err != nil{
    return nil,err
  }
  return pred,nil
}



func ToUserPredicate(filterExpr filter.Expr)(predicate.User,error){
visitor := &FilterVisitorUser{}
  v,err := filterExpr.Accept(visitor)
  if err != nil {
    return nil,err
  }
  return visitor.predicateFromVisitorResult(v),nil
}

type FilterVisitorUser struct{}

func (this *FilterVisitorUser) predicateFromVisitorResult(v interface{})(predicate.User){
	return v.(predicate.User)
}

func(this *FilterVisitorUser)	VisitBinaryLogicalExpr(expr *filter.BinaryLogicalExpr)(interface{},error){
	var logicalOperator = expr.Op

	left,err := expr.Left.Accept(this)
	if err != nil{
		return nil,err
	}
	right,err := expr.Right.Accept(this)
	if err != nil{
		return  nil,err
	}

	leftPred :=  this.predicateFromVisitorResult(left)
	rightPred :=  this.predicateFromVisitorResult(right)

	switch logicalOperator.Tpe{
		case filter.TokenType_KW_And:
		return user.And(
			leftPred,
			rightPred,
		), nil
		case filter.TokenType_KW_Or:
		return user.Or(
			leftPred,
			rightPred,
		), nil

	default:
		return nil,fmt.Errorf("unexptect logical operator %s",expr.Op.Literal)
	}
}

func(this *FilterVisitorUser)	VisitComparisionExpr(expr *filter.ComparisionExpr)(interface{},error){
	paths := strings.Split(expr.Left.GetStringValue(),".")
	if len(paths) == 1{
		var field = paths[0]
		switch field {
		
		
		case "name":
			switch expr.Op.Tpe {
				case filter.TokenType_KW_Eq:
					if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameEQ(expr.Right.GetStringValue()),nil
				case filter.TokenType_KW_Ne:
					if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameNEQ(expr.Right.GetStringValue()),nil
				case filter.TokenType_KW_Lt:
					if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameLT(expr.Right.GetStringValue()),nil
				case filter.TokenType_KW_Le:
					if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameLTE(expr.Right.GetStringValue()),nil
				case filter.TokenType_KW_Gt:
					if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameGT(expr.Right.GetStringValue()),nil
				case filter.TokenType_KW_Ge:
					if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameGTE(expr.Right.GetStringValue()),nil
				case filter.TokenType_KW_Like:if expr.Right.IsNumber(){
						return  nil,fmt.Errorf("the field name of node User type not matched, expect string but get number")
					}
					return user.NameContains(expr.Right.GetStringValue()),nil
				default: 
					return nil, fmt.Errorf("unexptected comparision operator %s",expr.Op.Literal)
			}
		
		
		case "age":
			switch expr.Op.Tpe {
				case filter.TokenType_KW_Eq:
					if !expr.Right.IsNumber(){
						return nil,fmt.Errorf("the field age of node User type not matched, expect number but get string")
					}
					return user.AgeEQ(int(expr.Right.GetNumberValue())),nil
				case filter.TokenType_KW_Ne:
					if !expr.Right.IsNumber(){
						return nil,fmt.Errorf("the field age of node User type not matched, expect number but get string")
					}
					return user.AgeNEQ(int(expr.Right.GetNumberValue())),nil
				case filter.TokenType_KW_Lt:
					if !expr.Right.IsNumber(){
						return nil,fmt.Errorf("the field age of node User type not matched, expect number but get string")
					}
					return user.AgeLT(int(expr.Right.GetNumberValue())),nil
				case filter.TokenType_KW_Le:
					if !expr.Right.IsNumber(){
						return nil,fmt.Errorf("the field age of node User type not matched, expect number but get string")
					}
					return user.AgeLTE(int(expr.Right.GetNumberValue())),nil
				case filter.TokenType_KW_Gt:
					if !expr.Right.IsNumber(){
						return nil,fmt.Errorf("the field age of node User type not matched, expect number but get string")
					}
					return user.AgeGT(int(expr.Right.GetNumberValue())),nil
				case filter.TokenType_KW_Ge:
					if !expr.Right.IsNumber(){
						return nil,fmt.Errorf("the field age of node User type not matched, expect number but get string")
					}
					return user.AgeGTE(int(expr.Right.GetNumberValue())),nil
				case filter.TokenType_KW_Like:return nil,fmt.Errorf("field Age of node User is not string type, cannot use like operator")
				default: 
					return nil, fmt.Errorf("unexptected comparision operator %s",expr.Op.Literal)
			}
		
		default:
			return nil, fmt.Errorf("undefined field < %s > for node < %s >",field,"User")
		}
	}else{ // filter for edge alias
    edge := paths[0]
    // check if edge alias exists
    switch edge{
    
    default:
      return nil,fmt.Errorf("undefined edge alis < %s > for node < User>",edge)
    }
	}
}

func(this *FilterVisitorUser)	VisitUnaryExpr(expr *filter.UnaryExpr)(interface{},error){
	var operator = expr.Op
	result,err := expr.Expr.Accept(this)
	if err != nil{
		return nil, err
	}
	switch operator.Tpe{
		case filter.TokenType_KW_Not:
    return user.Not(this.predicateFromVisitorResult(result)),nil
		default:
			return nil, fmt.Errorf("unexptect unary operator %s",operator.Literal)
	}
}

// }



// {

// }

// { တ7 functions to convert field value from interface to the real type


func UserNameValueFromInterface(v interface{})(value string,err error){
   // TODO sync with fieldTypeStr
  var ok bool
  value,ok = v.(string)
  if !ok {
    err = fmt.Errorf("The type of The field <$field.Name> of node < User> is  string")
    return
  }

  return
}

func UserAgeValueFromInterface(v interface{})(value int,err error){
   // TODO sync with fieldTypeStr
  var ok bool
  value,ok = v.(int)
  if !ok {
    err = fmt.Errorf("The type of The field <$field.Name> of node < User> is  int")
    return
  }

  return
}

func UserIDValueFromInterface(v interface{})(value int,err error){
   // TODO sync with fieldTypeStr
  var ok bool
  value,ok = v.(int)
  if !ok {
    err = fmt.Errorf("The type of The field <$field.Name> of node < User> is  int")
    return
  }

  return
}

// }


// { တ8 parse fields expr to field selector object which is used to select the field we want to query
func ParseUserFieldsSelector(fieldsStr string)(*UserFieldsSelector,error){
  fields := strings.Split(fieldsStr,",")
  selector := &UserFieldsSelector{
    Fields: make([]string,0,len(fields)),
  }
  for _,f := range fields {
    err := selector.AddField(f)
    if err != nil{
      return nil, err
    }
  }
  return selector,nil
}

type UserFieldsSelector struct{
  SelectAllField bool
  Fields []string
}

func (this *UserFieldsSelector) AddField(field string) error{
  elems := strings.Split(field,".")
  if  len(elems) == 1{
    f := elems[0]
    if f == "*"{
      this.SelectAllField = true
      return nil
    }
    this.Fields = append(this.Fields,f)
  }else{
      edgeAlias := elems[0]
      switch edgeAlias{
        default:
          return fmt.Errorf("undefined edge alias %s for node User",edgeAlias)
      }
  }
  return nil
}

func (this *UserFieldsSelector) Select(query *ent.UserQuery)error{
  if !this.SelectAllField{
    query.Select(this.Fields...)
  }
  return nil
}

// }
